---
typora-copy-images-to: ./assert
---

# HTTP协议、原生ajax、浏览器缓存机制

## http协议

前后台是通过 http 协议进行数据交互的，消息包括消息头、消息体

消息头（header）  限制 32k   头里面是一行一行的  如：

```
GET /api/content/link HTTP/1.1
Host: xxx.xxx.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Accept: */*
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36
Referer: http://xxx.xxx.com/xxx/xxx/xxx
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
```



消息体（body） 2G or 1G

* 其中 GET求时将数据放在 url 里面传输的，所以是放在请求头里面的，数据量小 并有缓存
* 而 POST 请求方式是将数据放在body里的，数据量大 ，不会缓存

form 表单很重要，一切ajax jsonp都是基于表单的：

* action 提交到哪儿
* method：请求方式（GET\POST\PUT\DELETE\HEAD）
  * GET 获取数据（不会像服务器发送大量数据）
  * POST\PUT 发送大数据给后台如文件上传
  * DELETE 删除东西（不会像服务器发送大量数据）
  * HEAD 让服务器只发送头回来就行了（应用场景：检测服务器是否还活着）
* enctype 
  * application/x-www-form-urlencoded（名字=值&名字=值... ...）默认方式
  * multipart/form-data （分块传输，用于文件上传）
  * application/json

## 原生 Ajax

XMLHttpRequest 对象的使用，（ajax用户体验好、性能高）

```javascript
let xhr = new XMLHttpRequest();
xhr.open("GET",URL,true);
xhr.send("这里面是body数据")；
xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
        //readyState === 4 表示通讯完成了
        if (xhr.status === 200 || xhr.status === 304) {
            //通讯完成了，并且成功了
            console.log(xhr.responseText);
        }
    }
}
```

readyState 有5 个值（5个状态）：

* 0 （未初始化）XMLHttpRequest 对象已经创建，但还没有调用open()方法。
* 1 刚调用 open() 方法之后还没有  send
* 2 刚 send 完
* 3 响应头接收完毕
* 4 响应体接收完毕

在 onreadystatechange 输出 xhr.readyState 只能看到 2、3、4

## Http 常见状态码

* 100  **客户端应当继续发送请求**。这个临时响应是用来通知客户端它的部分请求(http header)已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。
* 101  服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端**采用不同的协议**来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。
* 2 开头的这一类型的状态码，代表请求已成功被服务器**接收、理解、并接受**
* 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。（2开头的都表示成功）
* 3 开头的表示重定向
* 301 （**永久重定向**）被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。
* 302 （**临时重定向**）请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
* 304 （**未修改-协商缓存**） 自从上次请求以来该资源没有被修改（缓存）expires
* 4 开头的表示客户端错误
* 400 **语义有误**，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 **请求参数有误**。
* 404 **找不到**请求的资源
* 5 开头的表示服务器端错误
* 500 服务器错误，一般来说，这个问题都会在服务器的程序出错时出现
* 501 服务器不支持当前请求所需要的某个功能
* 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到**无效的响应**
* 503 （**服务不可用**）由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。
* 504 作为网关或者代理工作的服务器尝试执行请求时，**未能及时从上游服务器收到响应**

## 为什么要重定向

比如 taobao.com 用电脑访问就会重定向302到 --- `www.taobao.com` 而用手机访问就会302 到 `m.taobao.com`

## 响应数据的接收

* xhr.responseText 和 xhr.responseXML
* 可以用eval 和 JSON.stringify \ JSON.parse 对数据进行转化
* eval 存在安全上的问题，如跨站脚本攻击XSS（别人的js代码跑到我们的页面执行了），ajax不允许跨域就是为了防止XSS

## 缓存机制 协商缓存和强缓存
> 缓存会根据请求保存输出内容的副本，例如html页面，图片，文 件，当下一个请求来到的时候:如果是相同的URL，缓存直接使 用副本响应访问请求，而不是向源服务器再次发送请求。
> 减少相应延迟  减少网络带宽消耗

缓存机制在哪里配置呢？可以在   `nginx` 上面配置
浏览器第一次请求时： 服务器要和浏览器进行一个缓存协商，就是说我们要不要缓存？要缓存的话采取什么缓存策略，缓存多久

![408483-20160525182843100-1556227104](./assert/408483-20160525182843100-1556227104.png)



浏览器后续再进行请求时：

![408483-20160525182943272-204994049](./assert/408483-20160525182943272-204994049.png)

浏览器缓存包含两种类型，即**强缓存**（也叫本地缓存）和**协商缓存**

浏览器在第一次请求发生后，再次请求时：

浏览器在请求某一资源时，会先获取该资源缓存的header信息，

* 判断**是否命中强缓存**（**cache-control和expires信息**），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就**不会与服务器进行通信**
* 如果没有命中强缓存，浏览器会**发送请求到服务器**，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是**并不返回资源内容**，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容

|  | **获取资源形式** | **状态码** |  **发送请求到服务器** |
| ---------------- | ---------- | -------------------- | ------------------------------------------ |
| **强缓存**       | 从缓存取   | 200（from cache）    | 否，直接从缓存取                           |
| **协商缓存**     | 从缓存取   | 304（not modified）  | 是，正如其名，通过服务器来告知缓存是否可用 |

### 强缓存相关的header字段

与强缓存相关的header字段有两个

* **expires**，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱

* **cache-control**：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：
  * **no-cache**：不使用本地缓存（强缓存）。需要使用协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
  * **no-store**：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 
  * **public**：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
  * **private**：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

**no-cache 不是不缓存的意思可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用** 
**no-store 彻底的禁用缓存，本地和代理服务器都不缓冲，每次都从服务器获取**

**如果cache-control与expires同时存在的话，cache-control的优先级高于expires**

### 协商缓存相关的header字段

协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，**这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段**

**Last-Modified/If-Modified-Since**
二者的值都是GMT格式的时间字符串，具体过程：

- - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间，例如Last-Modified: Thu,31 Dec 2037 23:59:59 GMT
  - 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值
  - 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header
  - 浏览器收到304的响应后，就会从缓存中加载资源
  - 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值

**Etag/If-None-Match**
这两个值是由服务器生成的每个资源的**唯一标识字符串**，只要资源有变化就这个值就会改变；其判断过程与**Last-Modified/If-Modified-Since**类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化

### 既生Last-Modified何生Etag

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

- 一些文件也许会**周期性的更改**，但是他的内容并不改变(**仅仅改变的修改时间**)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的**粒度是s级**的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
- 某些服务器**不能精确的得到文件的最后修改时间**。

这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。

Last-Modified与 ETag  是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

## 用户的行为对缓存的影响

![408483-20160525202949975-1541314356](./assert/408483-20160525202949975-1541314356.png)

一些问题：

* 本地的缓存策略没有过期，但是服务器上的资源已经修改怎么办？这就比较要命了，这有可能是缓存时间设置太长导致的，我们可以将缓存时间设置的短一些
* **在资源请求的URL中增加一个参数，比如：js/mian.js?ver=0.7.1。这个参数是一个版本号，每一次部署的时候变更一下，当这个参数变化的时候，强缓存都会失效并重新加载。这样一来，静态资源，部署以后就需要重新加载**
* 什么时候需要进行 缓存协商？只有在 200 的时候会进行协商。304 是不会协商的，因为没有忘客户端推送东西啊